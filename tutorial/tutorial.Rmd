---
title: Tutorial of the Fusion Programming Language (WIP)
author: Detlef Groth, University of Potsdam
date: 2026-01-30 19:55
---

`include tutorial.toc`

## Introduction

[Fusion](https://fusion-lang.org/) is a programming language which works as a transpiler, a tool which
translates code in the Fusion programming language into code of the
programming languages C, C++, C#, D, Java, JavaScript, Python, Swift, TypeScript and OpenCL.

<center>
![Diagram](https://kroki.io/graphviz/svg/eNptUMFOAyEQvfcrJvWiKbrqHS_bejBGjfbW9MAu0zIphRXY1o3pv8sC0R4kZCbMvPfmDZK2TnQK5vA9gXjSa6XFYPvAw9F2xJy1gdeLl-XifZ0wxkpc-TBo5BvSGiUbU2u1ddwLvbeGeSU65I39YkeSQfG7m9vMdcLsPHb8HqoKPIZYkNR7BmTibRX6DPubCSMSfRCNJq8gKIRLMgfy1Gi8ghZNQJc8JWZVodwiFH8JmCdntbhag5o_9p5-bbbkWo3nS-yGRve4LoKF-o9m2QE_e5IULZoWQWid3HjYOLsv3DMHcP1Q_nosMZjWs9l0TBcxzhk8iYPI0beOusDehqCiV_g40iYwWA4dlg68dmjq56iT9E5Z9Xx_bzXJ9SQ3JqcfG_ia7w==)

[Edit this diagram](https://niolesk.top/#https://kroki.io/graphviz/svg/eNptUMFOAyEQvfcrJvWiKbrqHS_bejBGjfbW9MAu0zIphRXY1o3pv8sC0R4kZCbMvPfmDZK2TnQK5vA9gXjSa6XFYPvAw9F2xJy1gdeLl-XifZ0wxkpc-TBo5BvSGiUbU2u1ddwLvbeGeSU65I39YkeSQfG7m9vMdcLsPHb8HqoKPIZYkNR7BmTibRX6DPubCSMSfRCNJq8gKIRLMgfy1Gi8ghZNQJc8JWZVodwiFH8JmCdntbhag5o_9p5-bbbkWo3nS-yGRve4LoKF-o9m2QE_e5IULZoWQWid3HjYOLsv3DMHcP1Q_nosMZjWs9l0TBcxzhk8iYPI0beOusDehqCiV_g40iYwWA4dlg68dmjq56iT9E5Z9Xx_bzXJ9SQ3JqcfG_ia7w==)
</center>

For background on the difference between compilers and transpilers, have a
look at this [Geeks For Geeks Article](https://www.geeksforgeeks.org/compiler-design/difference-between-transpiler-and-compiler/).

## Installation

The transpiler for Fusion code is the [fut command-line application](https://github.com/fusionlanguage/fut).
There are binaries available for Intel/AMD/ARM systems for Linux, MacOS and Windows systems. You should download the latest version for your platform from the [release page](https://github.com/fusionlanguage/fut/releases/).
Here is an example for a Debian-like system using the
[dpkg](https://www.linuxbash.sh/post/using-dpkg-to-manually-install-deb-packages)
command line application:

```
VERSION=fut-3.2.13
wget https://github.com/fusionlanguage/fut/releases/download/${VERSION}/${VERSION}-1_amd64.deb
sudo dpkg -i ${VERSION}-1_amd64.deb
```

For MacOS, you would use the [Homebrew](https://brew.sh) package manager:

```
brew install fusionlanguage/fut/fut
```

## Hello World Example

As usually, we start with the standard "Hello World!" example. 

Fusion is not meant for writing full programs, but libraries which can be then
used from the aforementioned programming languages. However, Fusion supports the
creation of simple command-line applications, so here is our example and the expected output:

```{.shell label=Main cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main {
    public static void Main () {
        Console.WriteLine("Hello World!");
    }   
}
```

The above Fusion source code can be translated into a target programming language.
Here is an example for translating it into Python code and then executing it:

```
fut Main.fu -o out/main.py
python3 out/main.py
```

The Python output looks like this:

`include Main.py {{<pre class="py">} {</pre>}}` 


To compile to other targets, you just have to change the filename extension. Here is an example of creating D code:

```
fut Main.fu -o out/main.d
dmd out/main.d -of=out/main
./out/main 
Hello World!
```

The D language output looks like this:

`include out/main.d {{<pre class="py">} {</pre>}}` 


## Fusion Script Interpreter

In this tutorial we will use Python to directly execute the generated code
and embed the output into the document. For this, we will use a little Bash
script, which first generates Python code and then executes the generated script.

The Bash script looks like this:

```{.shell eval=FALSE,include=FALSE}
#INCLUDE "fuscript.sh"
```

## Other Programming Languages

### Lua

The output generated by the Fusion tool can be used to support even
more programming languages than the target languages of _fut_. For instance,
we can use a transpiler for TypeScript code to generate not only code for
different JavaScript interpreters, but also create for instance Lua code
from that TypeScript output. We can create Lua scripts from TypeScript code using the TypeScriptToLua transpiler [(tstl)](https://github.com/TypeScriptToLua/TypeScriptToLua). The workflow is as follows:

```{.kroki label=tstl,dia=graphviz,echo=FALSE}
digraph g {
    rankdir="LR"
    node[shape=doc,style=filled,fillcolor=grey90,width=1.2]
    "Hello.fu" -> "hello.ts"[label=fut]
    "hello.ts" -> "hello.lua"[label="npx tstl"]
}
```

Let's create a simple library file, _Hello.fu_ in a sub folder _assets_:_


`include assets/Hello.fu {<pre> </pre>}`

And now a Lua file to use that library:

`include assets/run-hello-tstl.lua {<pre> </pre>}`


A Makefile section for that conversion looks like this:

```{.shell label=tstlex,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
### npm install -D typescript-to-lua
fut -o assets/hello.ts assets/Hello.fu
npx tstl assets/hello.ts
cd assets && lua run-hello-tstl.lua
```

BTW: The file created by _tstl_ from the Typescript code looks like this:

`include assets/hello.lua {<pre> </pre>}`

The file *lualib_bundle.lua* imported here is a 82kb file which supports the
mapping from TypeScript to Lua code.

### V-lang

More important for using our Fusion code library is the C code output. C
code can be easily used by other programming languages. Here is an example
using the [V Programming Language](https://vlang.io/). To use the library, we
include the C header file and declare all functions we like to use from the
library file. For the same file _Hello.fu_ shown above, we create the
following V file.

`include assets/hello.v {<pre> </pre>}`

In this case, we will create a shared library from the hello file and then run
our file _hello.v_ like this:

```{.shell label=vhello,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
fut -o assets/hello.c assets/Hello.fu
cd assets 
gcc -shared hello.c -o libhello.so
LD_LIBRARY_PATH=. v run hello.v
cd ..
```

So we are not limited to the target languages for Fusion. Using the nicely
structured output, we can as well use transpilers for that output or simply
embed the C code in other programming languages. As C is the lingua franca of
programming, it should be possible, with more or less effort, to use the
generated code. There are existing as well other interface generators, for
example Swig, which we will present later.

### Go

The [Go programming language](https://go.dev) is the language that influenced the V language.
It also supports easy integration with C code. In the code,
the user places an include statement just before the `import "C"` statement.
Calls to C functions are then prefixed with the `C` letter.
Here is again the example where we use our hello library in a file run-hello.go.

`include ../samples/hello/go/run-hello.go pre`

The sequence of commands to compile the output would look like this:

```{.shell label=gohello,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
go version
fut -o assets/hello.c Hello.fu
cp ../samples/hello/go/run-hello.go assets/
cd assets 
go run run-hello.go
go build -x run-hello.go
cd ..
```

On older versions of the Go compiler, the variable `export CGO_ENABLED=1` must be set in your terminal.
The cgo approach has a few drawbacks,
such as missing support for C++ and the limited support for more
sophisticated data structures. Using Swig deals with some of these issues.
For a review of both methods, see this article of
[friendlyuser](https://friendlyuser.github.io/posts/tech/go/how_to_call_c_cplusplus_from_go/). 
For a Swig based approach, see the [samples/hello](../samples/hello) project which contains a simple
example of using Swig for creating wrapper code.


### Dart

In the Dart programming language, we use the `ffi` package to call functions from
compiled C libraries. So we can use the same file we used for the V
language. The project file for our Dart program using our hello library would look like this:

`include assets/pubspec.yaml {<pre> </pre>}`

and the code to execute these functions would look like this:


`include assets/hello.dart {<pre> </pre>}`


Our command line is very simple:

```{.shell label=darthello,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
fut -o assets/hello.c assets/Hello.fu
cd assets 
gcc -shared hello.c -o libhello.so
LD_LIBRARY_PATH=. dart run hello.dart
cd ..
```

So, we can see that we can support as well other language as the _fut_
transpiler should output clean C code which can be then used in even more programming
languages. 

### Swig - Simplified Wrapper and Interface Generator

Interfacing with C manually is somewhat cumbersome, so let's consider some automation.
For instance, the [Rust programming language](https://rust-lang.org/)
has a tool called [bindgen](https://github.com/rust-lang/rust-bindgen) to
simplify this process. There also exists a tool called [Swig](https://swig.org) which automates this process for more than a dozen target languages. A few of these languages, like C#, D, Java or Python, are already directly supported by Fusion. It might be still interesting to get a fast implementation by using the C library from Swig than the Fusion Python output, as the C code tends to be much faster than the Python code directly transpiled by the _fut_ tool.

For illustrative purposes, let's create bindings for two scripting languages, Lua and Tcl for our little hello library shown above.

### Swig and Lua 

Let's start with Lua. The process of creating a wrapper for a C library using
Swig is usually started by creating an interface file which includes the
header file of the C library. In the second section, we declare the functions we
would like to use from that include file. Alternatively, we can include here
the header file again to indicate that we would like to use all C functions
published in the header file. After we use Swig to create an interface C file, the original C and this wrapper file are then compiled either to a dynamic library or a static output file. For scripting languages, we usually create a static library. The process is as follows:


```{.kroki dia=graphviz,echo=FALSE}
digraph g {
rankdir="LR"
size="6,10"
edge[fontsize="24"]
node[shape=note,style=filled,fillcolor=cornsilk,height=2.2,width=1.5,fontsize=22]
Fu -> C[label=""]
Fu -> H[label="fut"]
H -> I[label="editor"]
I -> Wrap[label=" swig"]
Wrap -> SO[label="gcc"]
C -> SO[label=""]
Fu[label="Hello.Fu"]
C[label="hello.c"]
H[label="hello.h"]
I[label="hello.i"]
Wrap[label="hello_\nwrap.c"]
SO[label="hello.so"]
}
```

Let's have a look at an example interface file for Lua:

`include assets/hello.i {<pre> </pre>}`


Using the following command line, we can create a hello shared library file on Linux:

```{.shell label=luaswigello,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
if [ ! -d swig-lua ]; then mkdir swig-lua ; fi
cp assets/hello.i swig-lua
fut -o swig-lua/hello.c assets/Hello.fu
cd swig-lua
swig -lua -module hello -o hello_wrap.c hello.i
gcc -fPIC -I/usr/include/lua5.1 -c  hello_wrap.c -o hello_wrap.o
gcc -fPIC -I/usr/include/lua5.1 -c  hello.c -o hello.o
gcc -shared -I/usr/include/lua5.1 -L/usr/lib/x86_64-linux-gnu/  hello_wrap.o hello.o -o hello.so
### check if there is the function in the shared library
nm hello.so | grep GetMessage
cd ..
```

We can now try to run that function in a Lua script. Here is an example script:

`include assets/run-hello.lua {<pre> </pre>}`

```{.shell label=luaswigrun,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
cp assets/run-hello.lua swig-lua/
cd swig-lua 
lua run-hello.lua
```

### Swig and Tcl

Let's repeat that example with the Tcl programming language. As this is
also an interpreted language, we will again compile a shared library to be
used by Tcl. The interface file looks like this:


`include assets/tcl-hello.i {<pre> </pre>}`

Let's now create a shared library file and then pipe some Tcl code into the
tclsh interpreter:

```{.shell label=tclswighello,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
if [ ! -d swig-tcl ]; then mkdir swig-tcl ; fi
cp assets/tcl-hello.i swig-tcl/hello.i
fut -o swig-tcl/hello.c assets/Hello.fu
cd swig-tcl
swig -tcl8 -module hello hello.i                ## create the interface wrap file
gcc -fPIC -c hello.c                            ## compile the FU generated code
gcc -fPIC -c hello_wrap.c -I/usr/include/tcl8.6 ## compile the SWIG generated code
gcc -shared hello.o hello_wrap.o -o hello.so    ## combine both to a Tcl library
echo "load ./hello.so; puts \"This is Tcl [set tcl_patchLevel]!\"; puts [Hello_GetMessage];" | tclsh
```

If you are interested in more examples using Fusion with different language
targets, have a look at the examples in the
[samples/hello](https://github.com/mittelmark/fusion-tutorial/samples/hello)
folder of the project.



## Data Types

The main basic data types in Fusion are boolean, int, float and double. Other
integer types are byte, short, ushort and uint. Below you see how you
can create strings with embedded variable names. That does not work for
boolean values, so we create a helper method `BoolToInt` which converts the
boolean value to an integer.
 
```{.shell label=Main2 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
static class Main2 {
    public static int BoolToInt (bool b) => b ? 1 : 0;

    public static void Main (string[] args) {
        int x = 3 ;
        bool b = true;  // bools can't be printed directly
        bool c = false;
        byte y = 12; 
        float f = 1.234;        
        Console.WriteLine($" x={x} b={Main2.BoolToInt(b)} c={Main2.BoolToInt(c)} y={y} f={f}");
    }   
}
```


As we did not prefix this class declaration with the `public` keyword, this class will get transpiled to Python with a leading underscore.

Here is the output for the Python script :

`include Main2.py {{<pre class="py">} {</pre>}}` 

The output of the D language is not affected by the `public` keyword for the class.

## Type Conversions

Conversions from and to boolean type work differently in the programming languages that Fusion transpiles to.
For consistent behavior, we shall implement them ourselves:


```{.shell label=Main3 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main3 {
    public static int BoolToInt (bool b) => b ? 1 : 0;
    public static bool StringToBool (string b) => b.ToLower() == "true" || b == "1";
    public static void Main (string[] args) {
        string s1 = "true";
        bool b1 = Main3.StringToBool(s1);
        string s2 = "1";
        bool b2 = Main3.StringToBool(s2);
        string s3 = "false";
        bool b3 = Main3.StringToBool(s3);
        string s4 = "";
        bool b4 = Main3.StringToBool(s4);
        Console.WriteLine($"s1={BoolToInt(b1)} s2={BoolToInt(b2)}");
        Console.WriteLine($"s3={BoolToInt(b3)} s4={BoolToInt(b4)}");
    }   
}
```

## Parsing Integers

That problem is more serious. The main issue is what to do if we get an
invalid input. Usually an compile error, runtime error or exception is thrown
by the compiler or interpreter. That handling can be vary different. We solve
that problem here by returning an integer value which should be considered
invalid. That value in the following example has an value of -1 per default,
but these settings can be overwritten. Prefixing the call to `ParseInt` with
`Main4` in the `Main` method is required for C++ to
correctly call the appropriate method.

### Python Output

Here is our next Fusion file to do some basic integer parsing and the expected output:.

```{.shell label=Main4 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main4 {
    public static int ParseInt(string s, int invalid = -1) {
        int sign = 0;
        int i = 0;
        foreach (int c in s) {
            if (c >= '0' && c <= '9') {
                i = i * 10 + c - '0';
                sign |= 1;
            }
            else if (c == '-' && sign == 0)
                sign = -2;
            else if (c == '.') // stop at the decimal point
                break;
            else
                return invalid;
        }
        switch (sign) {
        case 1:
            return i;
        case -1:
            return -i;
        default:
            return invalid;
        }
    }
    public static void Main (string[] args) {
        string s1 = "12";
        int i1 = Main4.ParseInt(s1);
        string s2 = "-23";
        int i2 = Main4.ParseInt(s2);
        string s3 = "xyz";
        int i3 = Main4.ParseInt(s3);
        string s4 = "1234.5678";
        int i4 = Main4.ParseInt(s4);
        string s5 = "a1234.5678";
        int i5 = Main4.ParseInt(s5,-100);
        Console.WriteLine($"s1={s1} i1={i1}");
        Console.WriteLine($"s2={s2} i2={i2}");
        Console.WriteLine($"s3={s3} i3={i3}");
        Console.WriteLine($"s4={s4} i4={i4}");
        Console.WriteLine($"s5={s5} i5={i5}");        
    }   
}
```

That is the Python code which is generated by the command `fut Main4.fi -o Main4.py` and which was producing the output shown above:

`include Main4.py {<pre> </pre>}`

### D Output

Let's check if other languages are working correctly
with the given code. Let's try D first, then C and C++.


```{.shell label=Main4 cmd="fut %i -o main4.d&&dmd main4.d -of=main4-d&&./main4-d > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

Let's have a look at the generated D code:

`include main4.d {<pre> </pre>}`

### C Output

We will now repeat the same with C, here is the output of the C program:

```{.shell label=Main4 cmd="fut %i -o main4.c&&gcc main4.c -o main4-c&&./main4-c > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

Let's have a look at the generated C code:

`include main4.c {<pre> </pre>}`


And here is the generated header file:

`include main4.h {<pre> </pre>}`

The generated code looks clean and nice for using Swig to create library code for other languages. 

### C++ Output

But before we do this, let's repeat the procedure with C++. Here is the command to generate and compile the C++ code:

```
fut Main4.fu -o main4.cpp
g++ -std=c++20 main4.cpp -o main4-cpp
```

Please note that some features require the C++20 standard.

Here is the generated C++ code:

```{.shell label=Main4 cmd="fut %i -o main4.cpp&&cat main4.cpp > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

And here is the program output:

```{.shell label=Main4 cmd="fut %i -o main4.cpp&&g++ -std=c++20 main4.cpp -o main4-cpp&&./main4-cpp > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

## Native Language Code

Instead of writing Fusion code to parse integers, we might use target languages in `native` blocks.

Here is an example of the _StringUtils_ class which uses this approach. To create
code in the target language you have than to call the _fut_ transpiler with a `-D` option like this:

```
fut -D PY StringUtils.fi -o stringutils.py
python3 stringutils.py
```

```{.shell label=StringUtils cmd="fut -D PY %i -o %b.py&&python3 %b.py >  %b.txt" chunk.ext=fu ext=txt}
#if D
native {
import std.conv;
}
#elif CPP
native {
#include <cstdlib>
#include <iostream>    
}
#endif
static class StringUtils 
{
	public static int parseInt (string input) 
	{
		int i = 0;
#if PY
		native {
		i=int(input);
		}
#elif D
	native {
		i=to!int(input);
	}
#elif CPP
	native {
		std::string s = {input.begin(), input.end()};
		i=std::atoi(s.c_str());
	}
#endif 
		return(i);
	}
}
class Main2 
{
	public static void Main (string[] args) 
	{
		int x = 3 ;
		float f = 1.234;	
		int z = 0 ;
		z = StringUtils.parseInt("12345");
		Console.WriteLine($" x={x} f={f} z={z}");
	}
}
```

The resulting Python file looks like this:

`include StringUtils.py {<pre> </pre>}`

> [!CAUTION]
> The tricky thing in implementing Python code is to achieve the proper indentation. 
> To accomplish this you should indent your code using <b>tabs!</b>, because that's what the <i>fut</i> transpiler emits.

Let's look as well, just for curiosity, into the generated C++ code. That could
be generated and compiled using the following commands:


```{.shell label=compilecpp,cmd="bash %i > %b.txt" chunk.ext=sh ext=txt}
fut -D CPP StringUtils.fu -o stringutils.cpp
g++ -std=c++20 stringutils.cpp -o stringutils
./stringutils
```

Here is the code generated by _fut_:

`include stringutils.cpp {<pre> </pre>}`

We leave the creation and execution of D code generated by fut as an exercise
for the reader.

## Checking Input

Parsing strings to numbers or boelans is common task. To make it more safe we might check the string before we actually perform the parsing, so it might be good to have method `IsNumber` or `IsBoolean` returning `true` of `false` before we start actually the parsing.

Let's show some possible implementations, we compile this with the C++ compiler and then execute the file.

```{.shell label=Main5 cmd="fut %i -o main5.cpp&&g++ -std=c++20 main5.cpp -o main5-cpp&&./main5-cpp > %b.txt" chunk.ext=fu ext=txt,echo=TRUE}
#INCLUDE "assets/Main5.fu"
```

Here is another trial with D:

```{.shell label=Main5 cmd="fut %i -o main5.d&&dmd main5.d -of=main5-d&&./main5-d > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "assets/Main5.fu"
```

Just to prove it, I execute that on the command line:

```{.shell cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
ls -lth main?-*
./main5-d
```

## Documenting Code

TODO
